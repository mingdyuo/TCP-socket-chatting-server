- enum은 변수가 아님. 그냥 #define 보다는 조금 더 type에 대해 안전한 형태임. 

### listen socket의 backlog

커널은 listen 소켓에 대해 2가지 종류의 큐를 가지고 있다.

1. 불완전 연결 큐

   3악수 맺으려고 보낸 패킷을 저장하는 큐임. `SYN_RCVD` 상태임

2. 완전 연결 큐

   3악수 맺어진 클라의 패킷(소켓?)을 저장하는 큐임. `ESTABLISHED` 상태임

   `accept`되면 이 큐에 있는 맨 앞의 놈이 빠져나감

`backlog`가 뭐냐면 이 두 개의 큐에 있는 놈들의 합을 얼마까지 허용할 것인지 지정하는 것이다. 그래서 backlog만큼 큐에 애들이 꽉차면, 연결 요청이 들어와도 거절한다.

이 `backlog`값은 `SYN flooding` 공격과 관계가 있는데, 두 가지 방법으로 해결할 수 있다.

1. 큐를 늘리기 (백로그 값을 증가시키기)
2. 소켓이 불완전 큐에 남아있는 timeout 시간을 줄이기

[출처](https://m.blog.naver.com/PostView.nhn?blogId=s2kiess&logNo=220156878532&proxyReferer=https:%2F%2Fwww.google.com%2F)

### `std::vector`의 `reserve()`와 `resize()`

| `reserve()`                                                  | `resize()`                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| - capacity를 변경, 새로 입력한 capacity가 현재 capacity보다 작으면 아무 일도 일어나지 않음<br />- capacity보다 큰 값이 들어오면 모든 iterator와 레퍼런스가 invalidate된다.<br />- 공간을 예약하는 개념이다. 새로 받은 공간에 원소를 넣어주지는 않음 | - 배열의 원소 개수를 변경, 현재 크기보다 작은 값이 들어오면, 원소 개수를 줄임(제거함). 더 큰 값이 들어오면 기본 생성자를 호출해서 그만큼 채움 |

<br>

### window 스레드 생성 함수

1. `CreateThread()`

   Win32 API이다. 

   함수 호출 규약이 `__stdcall`이다.

   3번에 적혀있는 사항에 해당하지 않으면 이 함수를 사용하는 것이 좋다

2. `_beginthread()`

   C runtime library에 있다.

   함수 호출 규약이 `__cdecl`이다.

   이 함수는 스레드를 생성하고 바로 Handle을 닫아버리기 때문에 스레드 오브젝트와 통신이 불가능하다. 함수의 의도는 Win32의 내부적인 세부 사항을 숨기기 위한 것이지만, 버그처럼 되어버렸다. 그래서 `_beginthreadex()`에서는 이 사항이 수정되었다.

3. `_beginthreadex()`

   C runtime library에 있다.

   함수 호출 규약이 `__stdcall`이다.

   내부적으로는 CreateThread를 호출하는 함수다.

   스레드별로 내부적으로 별도의 메모리 공간을 할당한다. 그래서 동기화와 관련된 안정성을 보장받을 수 있다.

   이런 경우 쓰는 것이 좋다

   - 부동 소수형 변수나 함수를 사용하는 경우

   - 동적 할당을 하는 경우

   - `stdio.h`나 `io.h`에서 어떤 함수를 호출하는 경우

   - `strtok()`나 `rand()`와 같이 정적 버퍼를 사용하는 어떤 런타임 함수를 호출하는 경우

     → 멀티스레드 환경에서 문제가 될 수 있으므로, c 런타임 함수를 위한 각각의 전역 자원공간을 스레드마다 할당하는 것이 안전함

- 기타

  `_beginthread()`와 `_endthread()` 그리고 `_beginthreadex()`와 `_endthreadex()`는 짝을 이루며 명시적으로 호출해도 되고, 호출하지 않고 return 으로 스레드를 종료시킬 수 있다. 

  그러나 

  `_endthread()`는 자동으로 스레드 핸들을 닫으므로 명시적으로 핸들을 닫으면 안된다.

  `_endthreadex()`는 자동으로 스레드 핸들을 닫지 않으므로 명시적으로 닫아야 한다.

<br>

### `AcceptEx()`함수

- `accept()`는 동기지만, `AcceptEx()`는 비동기 함수이다.

- 한번의 함수 호출로 연결 수용 & 클라이언트 주소 정보 기록 & 첫번째 바이트 스트림 수신한다.

- 필요한 것 : Listen socket, accept socket(클라이언트가 새로 할당될 소켓)

  이 때 accept socket은 반드시 열린 소켓이어야 함. 닫힌 소켓이거나 bind된 소켓이면 안됨

- 서버의 최대 수용 클라이언트를 접속에서 미리 차단할 수 있다는 장점이 있다. 

[AcceptEx 함수 참고](https://programmingdiary.tistory.com/4)

[AcceptEx 함수 참고2](https://symlink.tistory.com/52)

- 소켓을 생성하는 것은 시스템 입장에서 부담스러운 작업이다. 윈속 2.0의 레이어 구조 때문에 여러 레이어의 프로바이더를 거쳐서 소켓을 생성하기 때문이다.

  입출력 완료를 처리하는 스레드는 완료 작업을 빨리 하기 위해 스레드 내에 복잡한 계산이 필요한 작업은 피하는 것이 좋다.

  작업 완료를 통지 받는 스레드 (GQCS)와 그에 따른 처리를 하는 스레드를 분리하는 것을 권장한다.

<br>

### 윈속 TCP 통신 시의 버퍼 구조

- 3개 층에 걸쳐서 버퍼가 존재한다.

  1. 응용 프로그램의 버퍼 (소켓의 송수신 함수 호출 시 전달)
  2. 소켓의 버퍼
  3. TCP의 버퍼

- 사용하는 방식은 다음과 같다.

  "전송할 때"와 "수신할 때"라 함은 전송 및 수신 함수를 호출했다는 것이다.

  1. 전송할 때 & 소켓의 전송 버퍼에 공간이 존재할 때
     - 애플리케이션의 데이터를 복사하고 즉시 성공을 반환한다.
     - Overlapped I/O가 완료되었음을 통보한다
  2. 전송할 때 & 소켓의 전송 버퍼가 꽉 찼을 때
     - 애플리케이션의 Overlapped buffer가 잠긴다 (lock이 걸린다)
     - `WSA_IO_PENDING`의 상태를 가지며 실패를 반환한다.
     - 소켓 버퍼의 데이터가 다 처리된 후, 어플리케이션의 전송 버퍼에 직접 접근해서 처리된다.
  3. 수신할 때 & 소켓 수신 버퍼에 데이터가 이미 도착한 경우
     - 애플리케이션의 수신 버퍼에 데이터가 복사된다.
     - 완료가 통보된다.
  4. 수신할 때 & 소켓의 수신 버퍼가 비어 있는 경우 (소켓이 받은게 아직 없음)
     - 애플리케이션의 수신 버퍼가 잠긴다.
     - `WSA_IO_PENDING`의 상태를 가지며 실패를 반환한다.
     - 수신할 데이터가 도착하면 애플리케이션의 수신 버퍼에 직접 복사된다.

<br>

### Locked page

- 버퍼가 lock되면(잠겨지면) 물리적인 메모리로 페이징 되지 않는다. OS는 잠길 수 있는 메모리의 한계를 정해놓았는데, 이 한계에 도달하면 Overlapped I/O 호출이 `WSAENOBUFS`의 상태로 실패한다.
- 연결마다 많은 수의 overlapped I/O를 호출하면, 연결의 수가 증가할 수록 잠길수 있는 메모리의 양이 한계에 다다를 것이다.

<br>

### Non-paged pool

- non-paged pool은 물리적인 메모리에 올라와있으면서 페이징되지 않는 영역이다. 드라이버같은 커널 모드 컴포넌트가 이 영역에 속한다.

  윈속같은 프로토콜 드라이버도 여기에 속한다. 소켓을 생성할 때마다 상태 정보를 저장하는 공간이 non-paged pool에서 조금씩 할당된다.

  (소켓은 2KB, `accept`나 `AcceptEx`에 의해 리턴된 소켓은 1.5KB - 주소만 저장하기 때문)

  (overlapped I/O별로 IRP 발생시키면서 500바이터 정도 소모)

- 연결이 증가할 수록 non-paged pool의 문제가 심각해진다.

- NPP가 부족하면 `WSANOBUFS`에러를 발생시키거나, 시스템이 손상될 수 있다. 

<br>

### 서버의 분류

1. 대용량 처리 (high throughput)

   - 대표적인 예시 : FTP 서버

   - 가져야 하는 능력

     → 대량의 데이터 송/수신, 각 연결에 대한 전송 시간 최소화

   - 이를 위해

     → 동시에 연결할 수 있는 연결 수를 제한하거나 거부하는 경우가 많다. 

     → 충분한 수의 송수신 overlapped I/O 요청을 유지해야 한다.

   - 일정한 수의 연결을 세트로 처리하는 방식을 사용할 수 있다. 예를 들면 100개씩 FIFO 방식으로 처리하는 것이다.

2. 대량 연결 (high connections)

<br>

### 소켓의 연결 종료

1. `shutdown(how)`

   `how`를 인자로 받음. `SD_SEND`, `SD_BOTH`를 넣는 경우 더 이상 보낼 데이터가 없다는 의미이며 `FIN` 패킷을 상대방에게 전송

   4-way handshake를 유도한다.

2. 한번 `shutdown`된 소켓을 다시 되돌릴 수는 없다. 재활용 할 수 없고 새로 생성해야 한다.

3. `shutdown()`은 어플리케이션의 읽고 쓰는 함수를 동작하지 않도록 막는 역할을 한다. 

   수신 소켓 버퍼를 비우고, 송신 소켓 버퍼로의 복사를 막는다.

   이미 송신 소켓 버퍼에 있는 데이터를 지우거나 송신을 막지는 않는다.

   GQCS를 통한 결과의 통보는 막지 않으며, `shutdown`이전에 걸린 `WSARecv()`는 `0` byte를 받는다.

4. `closesocket()`

   `shutdown`과 비슷하게 종료 동작을 수행한다. 다만 `shutdown`은 바로 `FIN`을 보내지만, `closesocket`은 자신의 소켓 버퍼에 쌓인 데이터 및 소켓의 옵션에 따라 다르게 동작한다.

   또한 리소스를 반환하는 동작도 수행한다.

   - `onoff == 0`

     소켓 큐의 데이터 처리를 전부 하지 않고 바로 소켓을 종료한다.

     이 경우 `RST` 패킷이 상대에게 날라간다.

     IOCP를 사용하는 경우, 상대는 비정상 조료의 의미로 GQCS는 `false`를 리턴하고 수신 바이트는 `0`이 될 것이다. 그리고 `ERROR_NETNAME_DELETED`라는 에러를 낼 것이다.

   - `onoff == 1`

     `linger` 값에 따라 동작이 달라진다. `linger` 값이 `0`이면 위와 동일하게 동작하고, 0이 아닌 경우 해당 값만큼 소켓 버퍼가 비워지기를 기다린다. 양쪽 버퍼가 다 비워질 때까지 기다리며, 모두 비워지면 `FIN`을 상대에게 전송한다.

[참고](https://chfhrqnfrhc.tistory.com/entry/%EC%86%8C%EC%BC%93-%EC%A2%85%EB%A3%8C)