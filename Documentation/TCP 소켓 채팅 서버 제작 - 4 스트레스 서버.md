### 스트레스 서버 제작

- IOCP 서버의 구조를 그대로 사용하되, Listen socket을 사용할 필요가 없다.

- 클라이언트를 생성하여 스트레스 서버가 아닌 채팅 서버에 연결하므로 `accept()`가 아닌 `connect()`를 사용한다.

- 3종류의 스레드를 사용해서 제작하였다.

  1. `ConnecterThread()`

     클라이언트를 생성하여 서버에 연결을 시도하는 스레드이다.

  2. `WorkerThread()`

     생성된 IOCP에 연결되어 I/O 큐를 받아오는 스레드이다. 14개 생성한다.

  3. `SenderThread()`

     임의로 클라이언트를 선택하여 임의의 텍스트 내용을 전송한다. `CHAT_BROADCAST`와 `CHAT_MULTICAST`의 두 종류 타입을 선택한다.



### 경과 기록

- 일반 클라이언트 프로그램의 전송 여부와 무관하게 소켓 에러가 나는지의 여부를 본다. 

  다만, 일반 클라이언트에서 패킷을 수신하여 화면에 띄우는 것은 잘 되어야 한다.

- 몇몇 클라이언트에서 에러가 발생할 수 있으나, 서버가 전체적으로 터지지 않는 경우를 쓴 것이다.

- 대부분의 시뮬레이션에서 채팅 서버의 CPU 점유율은 15 ~ 18%를 나타냈다.

  스트레스 서버의 CPU 점유율은 6~8%를 나타냈다.

  CPU : Intel i7-10700 2.9GHz

1. 클라이언트 생성 15ms 주기 / 패킷 전송 10ms 주기

   2000명 감당 하는듯

   2500명 감당 하는듯

   3000명 감당 하는듯

   ![image](https://user-images.githubusercontent.com/41130448/114333968-8c7e2e00-9b84-11eb-994f-58863ac05770.png)
   
   5000명
   
   ![image](https://user-images.githubusercontent.com/41130448/114345766-46819400-9b9d-11eb-8898-f12a247f8882.png)
   
   8000명
   
   ![image](https://user-images.githubusercontent.com/41130448/114346521-90b74500-9b9e-11eb-9ded-a81b2c1ad32c.png)
   
2. 클라이언트 생성 5ms 주기 / 패킷 전송 30ms 주기

   클라이언트가 많아질수록 broadcast할 때 패킷 하나 보내는 시간이 너무 오래걸려서 패킷을 조금 덜 생성하고, 연결이 얼마나 잘되는지 확인하기 위해서 클라이언트 생성 주기를 좀 낮추었다.

   10,000명 접속 감당하는 듯

   ![image](https://user-images.githubusercontent.com/41130448/114347388-d3c5e800-9b9f-11eb-8cee-b00faaa00ee9.png)

   10,000명 하면 자원을 이정도 사용한다.
   
   ![image](https://user-images.githubusercontent.com/41130448/114489713-8eacbf00-9c4e-11eb-80b1-3599b37cacea.png)
   
   Typora뭐야 오 ㅐ 안짤랐지
   
   엥 한 10분 넘게 돌리면 이상하게 채팅서버는 메모리가 거의 그대론데, 현재 스트레스 서버가 메모리를 190MB 사용하기 시작했다.
   
   아 스트레스 서버에서는 서버에서 주는 client full 응답을 받아서 처리하는 것을 안해놓아서 당연한 일이었다. 



### 생각해본 점

1. ~~클라이언트 생성하는 스레드의 생성 주기를 10~15ms 정도로 하면 금방 터진다.~~

   잘 안터지는듯?

2. 스트레스 서버를 켜놓는 동안 직접 클라이언트 프로그램을 켜서 생성하려고 하면 클라이언트 프로그램이 죽는다.

   클라이언트 프로그램을 먼저 켜고, 스트레스 서버를 작동시키는 것은 된다.

3. 내가 채팅을 쓰는 동안 다른 채팅이 오면 화면을 다시 그리게 되는데, 내가 쓴 채팅이 사라진다. 그러나 버퍼에는 남아 있어서 보내면 보내진다.

   → 클라이언트 단 콘솔 자체의 문제이므로 보류

4. 클라이언트 수가 몇천명 이상이 되면, `broadcast`할 때 매번 모든 클라이언트에게 보내므로 너무 큐에 자꾸 패킷이 쌓여서 오래 걸리는 것 같다. 실제 상황에서는 시야 처리를 해서 이렇게 몇천명이 서로 주고 받는 일은 없는지?

