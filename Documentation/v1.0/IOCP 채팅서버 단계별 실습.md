## IOCP 네트워크 프로그래밍 학습을 위한 단계별 실습

기반 코드 출처 : [[Youtube] IOCP 네트워크 프로그래밍 학습을 위한 단계별 실습](https://www.youtube.com/watch?v=q85zWBgN6PM&t=307s)

### 4단계 : 네트워크와 로직 처리 스레드를 분리하기

- 네트워크 처리 함수에서 패킷처리를 다 하고 있음

  이렇게 하면 패킷 처리를 멀티 스레드가 하는 것이므로 패킷 처리하는 부분에서 공유 객체에 대해 lock을 걸어 줘야 함 

  그래서 패킷 처리 하는 부분이 복잡해질 수 있음

  → 패킷 처리와 네트워크 처리 스레드를 각각 나누어서 해보자

- `IOCP thread`가 아닌 다른 함수에서 `ProcessPacket()`을 호출하도록 

### 5단계: 1-Send 구현하기

- 앞의 send 문제점은 send를 하나 보내고, 그게 완료되기 이전에 다시 send를 보낼 수 있다는 것임. 앞 단계에서 보낸 데이터가 다 가지 않은 경우 문제 발생할 수 있음. 이어서 보내지 못하게 됨. 

- 안전하게 데이터를 보낼 수 있도록 `1-send`를 구현하자. 

  `1-send`는 앞에서 send를 했을 때, 그 send 요청이 완료된 후 다시 다른 요청을 보내도록 하도록 하는 것

  버퍼에 쌓아놓고 send 스레드에서 보내기. 

  `n-send`는 반대 개념으로, 앞의 요청이 완료되는 것과 상관 없이 요청하는 대로 바로 보내는것

- 모든 클라이언트의 상태를 조사하다가, 연결된 상태고 보낼 수 있는 상황이면/보내야 하는 상황이면 처리

### 6단계: 1-Send 구현하기

- queue에 담아 놓고 순차적으로 보내기 

  send를 할 수 있는 상황이면 보내고, 안되는 상황이면 큐에 담아 놓고 있다가 iocp 스레드 쪽에서 send가 끝났을 때 큐를 확인하고 보낼 데이터가 있으면 보내는 것

- send용 스레드를 따로 쓰는 것이 아님 (5단계와의 차이점)

### 7단계: 비동기 Accept 사용하기

- 앞에서는 accept를 동기식으로 처리하고 있었음. 이 부분을 구현하기

### 8단계: 채팅 서버 만들기

- TCP는 string 구조이므로 패킷과 데이터를 구분할 수 없음. 이를 구분하기 위해서 헤더가 필요함
- 헤더를 정의해서 클라이언트에서 데이터를 보낼 때 같이 보냄

### 9단계: 로그인 때 Redis 사용하기 

- 패킷을 처리하는 스레드에서 레디스 작업을 하면 안됨. 레디스도 하나의 서버이고, 로그를 남기는 것이기 때문에 네트워크 대기가 생김
- 다른 IO 작업을 할 때에는 다른 스레드 만들어서 그쪽에서 처리 시키고 결과를 받아오는 방식으로 해야 함
- 비동기 패킷 처리와 스레드 간에 데이터를 주고받는 방법

### 10단계: 방 입장, 방 나가기, 방 채팅 구현하기

### 11단계: 최적화하기

- `GetQueuedCompletionStatusEx` 버전 사용하기
- 서버에서 사용하는 설정을 입력받기
- 동적 할당을 최소화하기
- 링버퍼 구현 추가(덮어쓰기 방기)
- Lock 사용 범위를 줄이거나 좀 더 가벼운 Lock 사용하기
- 더미 클라이언트로 테스트하기

### 12단계: Network, Content, Host 각 레이어로 프로젝트 나누기

- Network, Content는 각각 정적 라이브러리로 만든다.
- Host는 콘솔 프로젝트(실행 파일 만들어주는것). Network, Content 라이브러리를 사용한다. 

<br>



