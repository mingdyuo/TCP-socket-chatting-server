### 리팩토링 내역 (21년 5월 셋째주 - 넷째주)

- `IOCPServer` 코드를 정리하였다.

  `IOCP` 담당하는 코드, 패킷 클래스, `IO` 전용 구조체 모두 정리함

- 로그 클래스를 도입하였다. (`spdlog` 라이브러리 사용)

  추후 기능 리팩토링 완료 후 도입 예정이다.

  `stdout`과 file에 동시에 찍히는 로그이다.

- 패킷 관리 방식을 변경하였다.

  `struct`에서 → `Stream` 클래스로 직렬화 및 역직렬화가 용이하도록 변경하였다.

  추후 `Stream` pool 만들어서 매번 `Stream`객체 생성하는 오버헤드 줄이고자 한다.

- 클라이언트 리팩토링

  클라이언트에서도 I/O와 기능 로직을 분리하였다.

  `Display` 클래스를 따로 만들어서 상황에 따라서 다른 객체를 갖도록 변경하였다.

<br>

### 21년 5월 30일

- 채팅룸 디스플레이를 고민 중

  A라는 사람이 채팅을 치는 경우 처리를 고민중이다.

  1. A의 닉네임과 채팅 내역을 함께 보낼 지
  2. 클라이언트에 A의 id와 닉네임을 매핑해서 저장해두고 A의 아이디만 보낸 후 닉네임을 찾아서 출력할 지

  근데 클라이언트에 현재 접속중인 채팅방 내의 유저 정보를 저장해둔다고 하더라도 2번의 방법은 매번 잡다한 채팅이 올 때 마다 맵 내부를 탐색해야 한다. 쓸데없는 오버헤드가 너무 클 것 같다. 차라리 몇 바이트 소모하더라도 닉네임을 함께 보내는 것이 나을 것 같음

- 결론

  1. 채팅방에 입장 / 퇴장할 때 해당 입퇴장 유저 정보는 보낸다.
  2. 채팅을 치는 경우에는 송신 유저의 닉네임과 채팅 내용을 함께 보낸다.

- `User` 구조체에 `Room*`을 저장할지, `RoomId`를 저장할지 고민중

  `RoomId`를 저장하더라도 어차피 그걸 이용해서 `RoomManager`를 통해서 `Room`을 가지고 온 후 작업을 할 것이라고 예상됨. 그냥 처음부터 `Room*`를 저장해서 오버헤드를 조금 줄이는게 낫지 않을까용
