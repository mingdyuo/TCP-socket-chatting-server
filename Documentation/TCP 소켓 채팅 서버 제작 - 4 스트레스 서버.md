### 스트레스 서버 제작

- IOCP 서버의 구조를 그대로 사용하되, Listen socket을 사용할 필요가 없다.

- 클라이언트를 생성하여 스트레스 서버가 아닌 채팅 서버에 연결하므로 `accept()`가 아닌 `connect()`를 사용한다.

- 3종류의 스레드를 사용해서 제작하였다.

  1. `ConnecterThread()`

     클라이언트를 생성하여 서버에 연결을 시도하는 스레드이다.

  2. `WorkerThread()`

     생성된 IOCP에 연결되어 I/O 큐를 받아오는 스레드이다. 14개 생성한다.

  3. `SenderThread()`

     임의로 클라이언트를 선택하여 임의의 텍스트 내용을 전송한다. `CHAT_BROADCAST`와 `CHAT_MULTICAST`의 두 종류 타입을 선택한다.



### 경과 기록

- 일반 클라이언트 프로그램의 전송 여부와 무관하게 소켓 에러가 나는지의 여부를 본다. 

  다만, 일반 클라이언트에서 패킷을 수신하여 화면에 띄우는 것은 잘 되어야 한다.

- 몇몇 클라이언트에서 에러가 발생할 수 있으나, 서버가 전체적으로 터지지 않는 경우를 쓴 것이다.

- 대부분의 시뮬레이션에서 채팅 서버의 CPU 점유율은 15 ~ 18%를 나타냈다.

  스트레스 서버의 CPU 점유율은 6~8%를 나타냈다.

  CPU : Intel i7-10700 2.9GHz

1. 클라이언트 생성 15ms 주기 / 패킷 전송 10ms 주기

   2000명 감당 하는듯

   2500명 감당 하는듯

   3000명 감당 하는듯

   ![image](https://user-images.githubusercontent.com/41130448/114333968-8c7e2e00-9b84-11eb-994f-58863ac05770.png)
   
   5000명
   
   ![image](https://user-images.githubusercontent.com/41130448/114345766-46819400-9b9d-11eb-8898-f12a247f8882.png)
   
   8000명
   
   ![image](https://user-images.githubusercontent.com/41130448/114346521-90b74500-9b9e-11eb-9ded-a81b2c1ad32c.png)
   
2. 클라이언트 생성 5ms 주기 / 패킷 전송 30ms 주기

   클라이언트가 많아질수록 broadcast할 때 패킷 하나 보내는 시간이 너무 오래걸려서 패킷을 조금 덜 생성하고, 연결이 얼마나 잘되는지 확인하기 위해서 클라이언트 생성 주기를 좀 낮추었다.

   10,000명 접속 감당하는 듯

   ![image](https://user-images.githubusercontent.com/41130448/114347388-d3c5e800-9b9f-11eb-8cee-b00faaa00ee9.png)

   



### 발견한 문제점

1. 클라이언트 생성하는 스레드의 생성 주기를 10~15ms 정도로 하면 금방 터진다.
2. 스트레스 서버를 켜놓는 동안 직접 클라이언트 프로그램을 켜서 생성하려고 하면 서버가 패킷을 씹는다.
3. 내가 채팅을 쓰는 동안 다른 채팅이 오면 화면을 다시 그리게 되는데, 내가 쓴 채팅이 사라진다. 그러나 버퍼에는 남아 있어서 보내면 보내진다.

